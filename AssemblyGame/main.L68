000015C4 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 10/10/2024 7:35:53 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : Main function for Assembly game
00000000                             3  * Written by : Juno Strunk
00000000                             4  * Date       : 9/2/24
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8      
00001000                             9  * === EQU's, REG's & Includes ===
00001000                            10  
00001000                            11      INCLUDE     "memory.x68"
00001000                            12  
00001000                            13  NONVOL_REGS                 REG d2-d7/a2-a6
00001000                            14  MHEADER_REGS                REG d1-d2/a0    ; Registers for make header
00001000                            15  D2D3_REGS                   REG d2-d3
00001000                            16  
00001000  =00000000                 17  MEM_AUDIT_OFFS_FREE_CNT     EQU 0
00001000  =00000004                 18  MEM_AUDIT_OFFS_USED_CNT     EQU 4
00001000  =00000008                 19  MEM_AUDIT_OFFS_FREE_MEM     EQU 8
00001000  =0000000C                 20  MEM_AUDIT_OFFS_USED_MEM     EQU 12
00001000  =00000010                 21  MEM_AUDIT_OVERHEAD_SIZE     EQU 16
00001000  =00000014                 22  MEM_AUDIT_RETURN_SIZE       EQU 20
00001000                            23  
00001000  =FFFFFFF8                 24  MEM_OFFSET_GETSIZE          EQU -8 * Update with header
00001000                            25  
00001000  =00000000                 26  MEM_OFFSET_SIZE             EQU 0
00001000  =00000004                 27  MEM_OFFSET_NEXT             EQU 4 * Includes header size
00001000  =00000008                 28  MEM_HEADER_SIZE             EQU 8 * !!! update this value based on your header layout
00001000                            29  
00001000                            30  mem_InitHeap:
00001000                            31      * Offload d2
00001000  2F02                      32      move.l  d2, -(sp)
00001002                            33  
00001002                            34      * Keep track of start address
00001002  23C9 0000121C             35      move.l  a1, MEM_START_HEAP
00001008  2001                      36      move.l  d1, d0
0000100A  D089                      37      add.l   a1, d0
0000100C  23C0 00001220             38      move.l  d0, MEM_END_HEAP
00001012                            39  
00001012                            40      * Make header
00001012  7001                      41      move.l  #1, d0
00001014                            42      * d1 already set
00001014  2401                      43      move.l  d1, d2    
00001016  2049                      44      move.l  a1, a0
00001018  6100 01CA                 45      bsr     make_Header
0000101C                            46      * d0 set to success or failure in make_Header
0000101C                            47      
0000101C  241F                      48      move.l  (sp)+, d2
0000101E  4E75                      49      rts
00001020                            50  
00001020                            51  mem_Audit:
00001020                            52      * d0 - Size of alloc
00001020                            53      * d1 - Next alloc
00001020                            54      
00001020                            55      * Add 4 (1 lw) to SP, so that we're not writing
00001020                            56      * into our return address
00001020  588F                      57      add.l   #4, sp
00001022                            58      
00001022                            59      * Clear outputs
00001022  2F7C 00000000 0000        60      move.l   #0, MEM_AUDIT_OFFS_FREE_CNT(sp)
0000102A  2F7C 00000000 0004        61      move.l   #0, MEM_AUDIT_OFFS_USED_CNT(sp)
00001032  2F7C 00000000 0008        62      move.l   #0, MEM_AUDIT_OFFS_FREE_MEM(sp)    
0000103A  2F7C 00000000 000C        63      move.l   #0, MEM_AUDIT_OFFS_USED_MEM(sp)
00001042  2F7C 00000000 0010        64      move.l   #0, MEM_AUDIT_OVERHEAD_SIZE(sp)
0000104A                            65  
0000104A                            66      * Start at beginning of heap
0000104A  2079 0000121C             67      move.l  MEM_START_HEAP, a0
00001050                            68      
00001050                            69  .search
00001050  B1F9 00001220             70      cmp.l   MEM_END_HEAP, a0
00001056  6C00 0032                 71      bge     .done
0000105A                            72      
0000105A  50AF 0010                 73      add.l   #MEM_HEADER_SIZE, MEM_AUDIT_OVERHEAD_SIZE(sp)
0000105E                            74      
0000105E                            75      * Get header information
0000105E  2028 0000                 76      move.l  MEM_OFFSET_SIZE(a0), d0 ; size of alloc
00001062  2228 0004                 77      move.l  MEM_OFFSET_NEXT(a0), d1 ; next alloc
00001066                            78      
00001066                            79      * Test last bit in size header to see if free
00001066  0828 001F 0000            80      btst    #$1F, MEM_OFFSET_SIZE(a0)
0000106C  6600 000E                 81      bne     .free
00001070                            82  
00001070                            83  .allocd
00001070                            84      * Add values to used
00001070  52AF 0004                 85      add.l   #1, MEM_AUDIT_OFFS_USED_CNT(sp)
00001074  D1AF 000C                 86      add.l   d0, MEM_AUDIT_OFFS_USED_MEM(sp)
00001078  6000 000C                 87      bra     .inc
0000107C                            88      
0000107C                            89  .free
0000107C                            90      * Add values to free
0000107C  4480                      91      neg.l   d0
0000107E  52AF 0000                 92      add.l   #1, MEM_AUDIT_OFFS_FREE_CNT(sp)
00001082  D1AF 0008                 93      add.l   d0, MEM_AUDIT_OFFS_FREE_MEM(sp)
00001086                            94  
00001086                            95  .inc
00001086                            96      * Add size of block to a0
00001086  D1C1                      97      add.l   d1, a0
00001088  60C6                      98      bra     .search
0000108A                            99      
0000108A                           100  .done
0000108A                           101      * Reset SP and return
0000108A  598F                     102      sub.l   #4, sp
0000108C  7000                     103      move.l  #0, d0
0000108E  4E75                     104      rts
00001090                           105      
00001090                           106  .error
00001090                           107      * Reset SP and return
00001090  598F                     108      sub.l   #4, sp
00001092  7001                     109      move.l  #1, d0
00001094  4E75                     110      rts
00001096                           111            
00001096                           112  mem_Alloc:
00001096                           113      * Offload non-volatile regs
00001096  48E7 3000                114      movem.l D2D3_REGS, -(sp)
0000109A                           115      
0000109A                           116      * Start at the beginning of the heap
0000109A  2079 0000121C            117      move.l  MEM_START_HEAP, a0
000010A0                           118      
000010A0                           119      * Iterate through heap to find free space
000010A0                           120      * a0 - Address of allocation
000010A0                           121      * d2 - MEM_OFFSET_SIZE(a0)
000010A0                           122      * d3 - MEM_OFFSET_NEXT(a0)
000010A0                           123  .search
000010A0                           124      
000010A0                           125      * See if address is less than end
000010A0  B1F9 00001220            126      cmp.l   MEM_END_HEAP, a0
000010A6  6C00 0066                127      bge     .error  ; no space found in heap
000010AA                           128      
000010AA                           129      * Get size of block (Just size no header)
000010AA  2428 0000                130      move.l  MEM_OFFSET_SIZE(a0), d2
000010AE                           131      * Get size of block (size + header)
000010AE  2628 0004                132      move.l  MEM_OFFSET_NEXT(a0), d3
000010B2                           133          
000010B2                           134      * Test last bit in size header to see if free
000010B2  0828 001F 0000           135      btst    #$1F, MEM_OFFSET_SIZE(a0)
000010B8  6600 0006                136      bne     .free_found
000010BC                           137      
000010BC                           138  .inc
000010BC                           139      * Add size of block to a0
000010BC  D1C3                     140      add.l   d3, a0
000010BE  60E0                     141      bra     .search
000010C0                           142      
000010C0                           143  .free_found
000010C0                           144      
000010C0  4482                     145      neg.l   d2
000010C2                           146      * Check if free space is big enough
000010C2  B481                     147      cmp.l   d1, d2
000010C4  6DF6                     148      blt     .inc        ; if not big enough increment and keep searching
000010C6  6700 0032                149      beq     .no_Split   ; if just big enough, skip the splitting
000010CA                           150      
000010CA                           151      * Split block ---
000010CA                           152      
000010CA                           153      * Offload for when we think there isn't a split
000010CA                           154      * But there really is (not enough space for header)
000010CA  2F03                     155      move.l  d3, -(sp)
000010CC                           156      
000010CC                           157      * Set up values found by getting d1 + HEADERSIZE
000010CC  2248                     158      move.l  a0, a1
000010CE  5081                     159      add.l   #MEM_HEADER_SIZE, d1
000010D0  D3C1                     160      add.l   d1, a1
000010D2  2401                     161      move.l  d1, d2
000010D4  9681                     162      sub.l   d1, d3
000010D6  5181                     163      sub.l   #MEM_HEADER_SIZE, d1 
000010D8                           164      * a1 - Address of next block
000010D8                           165      * d2 - MEM_OFFSET_SIZE of NEW ALLOC'D block
000010D8                           166      * d3 - MEM_OFFSET_NEXT of next block
000010D8                           167      
000010D8  48E7 6080                168      movem.l MHEADER_REGS, -(sp)
000010DC                           169      
000010DC                           170      * Make split block header ---
000010DC                           171      * --- make_Header inputs
000010DC                           172      * a0 - Start of allocation
000010DC                           173      * d0.b - 0 = Alloc'd, non-zero = free
000010DC                           174      * d1.l - Size of allocation (Including header)
000010DC                           175      * d2.l - Bytes until next header
000010DC                           176      * ---
000010DC                           177      
000010DC  2049                     178      move.l  a1, a0
000010DE  103C 0001                179      move.b  #1, d0  ; d0 = 1 since header will be free
000010E2  2203                     180      move.l  d3, d1  ; d1 and d2 have remaining block
000010E4  2403                     181      move.l  d3, d2
000010E6  6100 00FC                182      bsr     make_Header
000010EA                           183      * If unable to make header (not enough space)
000010EA                           184      * Then reset d2 to be to the end of the original block
000010EA                           185      
000010EA  4CDF 0106                186      movem.l (sp)+, MHEADER_REGS
000010EE                           187      
000010EE                           188      * Reload d3
000010EE  261F                     189      move.l  (sp)+, d3   
000010F0                           190  
000010F0  4A00                     191      tst.b   d0
000010F2  6600 0006                192      bne     .no_Split
000010F6                           193      
000010F6  6000 0004                194      bra     .fill_Alloc
000010FA                           195      
000010FA                           196  .no_Split
000010FA  2403                     197      move.l  d3, d2
000010FC                           198  .fill_Alloc    
000010FC                           199  
000010FC                           200      * Make header
000010FC                           201      * a0 already has allocStart
000010FC  4200                     202      clr.b   d0                      ; d0 = 0, sets header to used
000010FE  5081                     203      add.l   #MEM_HEADER_SIZE, d1    ; make_Header expects allocation + header size
00001100                           204      * d2 should be set above
00001100  6100 00E2                205      bsr     make_Header
00001104  4A00                     206      tst.b   d0
00001106  6600 0006                207      bne     .error
0000110A                           208      
0000110A  6000 0006                209      bra     .done
0000110E                           210      
0000110E                           211  .error
0000110E  103C 0001                212      move.b  #1, d0
00001112                           213      
00001112                           214  .done
00001112  4CDF 000C                215      movem.l (sp)+, D2D3_REGS
00001116  4E75                     216      rts
00001118                           217      
00001118                           218  mem_Free:
00001118                           219      * Get size
00001118  5189                     220      sub.l   #MEM_HEADER_SIZE, a1
0000111A  2229 0000                221      move.l  MEM_OFFSET_SIZE(a1), d1
0000111E                           222      
0000111E                           223      * Check and make sure block is allocated
0000111E  6B00 0018                224      BMI     .error ; double free!
00001122                           225      
00001122                           226      * Otherwise free
00001122  4481                     227      neg.l   d1
00001124  2341 0000                228      move.l  d1, MEM_OFFSET_SIZE(a1)
00001128                           229      
00001128  2079 0000121C            230      move.l  MEM_START_HEAP, a0
0000112E  6100 0056                231      bsr     mem_Coalesce
00001132                           232      
00001132  7000                     233      move.l  #0, d0  ; no error
00001134  6000 0004                234      bra     .done
00001138                           235  
00001138                           236  .error
00001138  7001                     237      move.l  #1, d0
0000113A                           238      
0000113A                           239  .done
0000113A  4E75                     240      rts
0000113C                           241      
0000113C                           242  mem_Shrink: 
0000113C                           243      * subtract d1 from old alloc's size to get size of new space
0000113C                           244      * Update old header size
0000113C                           245      * add d1 to a1 to get start of new free space
0000113C                           246      * make header of new space
0000113C                           247      
0000113C                           248      * Add new size to start of alloc
0000113C                           249      * to get new start of freed alloc
0000113C  2049                     250      move.l  a1, a0
0000113E  D1C1                     251      add.l   d1, a0
00001140                           252      
00001140                           253      * Subtract header size from a1 to get start of alloc
00001140  5189                     254      sub.l   #MEM_HEADER_SIZE, a1
00001142                           255      
00001142                           256      * Move old size into d0
00001142  2029 0000                257      move.l  MEM_OFFSET_SIZE(a1), d0
00001146                           258      
00001146                           259      * Make sure d1 is less than current size
00001146  B280                     260      cmp.l   d0, d1
00001148  6700 0032                261      beq     .done
0000114C  6E00 0032                262      bgt     .error
00001150                           263      
00001150                           264      * Make sure block is actually allocated
00001150  0800 001F                265      btst    #$1F, d0
00001154  6600 002A                266      bne     .error
00001158                           267      
00001158                           268      * Set new size into header
00001158  2341 0000                269      move.l  d1, MEM_OFFSET_SIZE(a1)
0000115C                           270      
0000115C                           271      * Subtract new size from old size
0000115C  9081                     272      sub.l  d1, d0
0000115E                           273      * d0 = Size of new freed block (Header + Buffer) ---
0000115E                           274      
0000115E                           275      * Set size/next offset of freed block
0000115E  2140 0000                276      move.l  d0, MEM_OFFSET_SIZE(a0)
00001162  51A8 0000                277      sub.l   #MEM_HEADER_SIZE, MEM_OFFSET_SIZE(a0)
00001166  44A8 0000                278      neg.l   MEM_OFFSET_SIZE(a0)
0000116A  2140 0004                279      move.l  d0, MEM_OFFSET_NEXT(a0)
0000116E                           280      
0000116E                           281      * Get size of new next of allocd block
0000116E  2229 0004                282      move.l  MEM_OFFSET_NEXT(a1), d1
00001172  9280                     283      sub.l   d0, d1
00001174                           284      
00001174                           285      * Set new next into header
00001174  2341 0004                286      move.l  d1, MEM_OFFSET_NEXT(a1)
00001178                           287      
00001178  6100 000C                288      bsr     mem_Coalesce
0000117C                           289      
0000117C                           290  .done
0000117C  7000                     291      move.l  #0, d0
0000117E  4E75                     292      rts
00001180                           293      
00001180                           294  .error
00001180  103C 0001                295      move.b  #1, d0
00001184  4E75                     296      rts
00001186                           297      
00001186                           298  mem_Coalesce:
00001186                           299      * Offload non-volatile regs
00001186                           300  
00001186                           301      * Check for not in range
00001186  B1F9 0000121C            302      cmp.l   MEM_START_HEAP, a0
0000118C  6D00 004A                303      blt     .error
00001190                           304      
00001190                           305  .search
00001190                           306      
00001190                           307      * See if address is less than end
00001190  B1F9 00001220            308      cmp.l   MEM_END_HEAP, a0
00001196  6C00 0046                309      bge     .done   ; no space found in heap
0000119A                           310      
0000119A                           311      * Get size of block (Just size no header)
0000119A  2028 0000                312      move.l  MEM_OFFSET_SIZE(a0), d0
0000119E                           313      * Get size of block (size + header)
0000119E  2228 0004                314      move.l  MEM_OFFSET_NEXT(a0), d1
000011A2                           315          
000011A2                           316      * Test last bit in size header to see if free
000011A2  0828 001F 0000           317      btst    #$1F, MEM_OFFSET_SIZE(a0)
000011A8  6600 0006                318      bne     .free_found
000011AC                           319      
000011AC                           320  .inc
000011AC                           321      * Add size of block to a0
000011AC  D1C1                     322      add.l   d1, a0
000011AE  60E0                     323      bra     .search
000011B0                           324      
000011B0                           325  .free_found
000011B0                           326      * Look forward to see if next one is free as well
000011B0  2248                     327      move.l  a0, a1
000011B2  D3C1                     328      add.l   d1, a1
000011B4                           329      
000011B4                           330      * Make sure address is in range
000011B4  B3F9 00001220            331      cmp.l   MEM_END_HEAP, a1
000011BA  6C00 0022                332      bge     .done
000011BE                           333      
000011BE                           334      * Test last bit in size header to see if free
000011BE  0829 001F 0000           335      btst    #$1F, MEM_OFFSET_SIZE(a1)
000011C4  67E6                     336      beq     .inc    ; if not free keep looking
000011C6                           337      
000011C6                           338      * Get lower block's size, add to higher block
000011C6  2029 0000                339      move.l  MEM_OFFSET_SIZE(a1), d0
000011CA  5180                     340      sub.l   #MEM_HEADER_SIZE, d0
000011CC  D1A8 0000                341      add.l   d0, MEM_OFFSET_SIZE(a0)
000011D0  4480                     342      neg.l   d0
000011D2  D1A8 0004                343      add.l   d0, MEM_OFFSET_NEXT(a0)
000011D6                           344      
000011D6  60B8                     345      bra     .search ; keep looking after merging
000011D8                           346  
000011D8                           347  .error
000011D8  103C 0001                348      move.b  #1, d0
000011DC  4E75                     349      rts
000011DE                           350      
000011DE                           351  .done
000011DE  103C 0000                352      move.b  #0, d0
000011E2  4E75                     353      rts
000011E4                           354      
000011E4                           355  make_Header:
000011E4                           356      
000011E4                           357      * Check if there is even enough size
000011E4  B2BC 00000008            358      cmp.l   #MEM_HEADER_SIZE, d1
000011EA  6F00 0020                359      ble     .error
000011EE                           360  
000011EE                           361      * Make Header ---
000011EE                           362      
000011EE                           363      * Subtract out header size
000011EE                           364      * Make negative because it's all free
000011EE  5181                     365      sub.l   #MEM_HEADER_SIZE, d1
000011F0                           366      
000011F0                           367      * Set offset to next
000011F0  2142 0004                368      move.l  d2, MEM_OFFSET_NEXT(a0)
000011F4                           369      
000011F4                           370      * If making free header make size negative
000011F4                           371      * Otherwise just set the size
000011F4  B03C 0000                372      cmp.b   #0, d0
000011F8  6700 0004                373      beq     .setSize
000011FC  4481                     374      neg.l   d1
000011FE                           375      
000011FE                           376  .setSize
000011FE  2141 0000                377      move.l  d1, MEM_OFFSET_SIZE(a0)
00001202  5088                     378      add.l   #MEM_HEADER_SIZE, a0
00001204  103C 0000                379      move.b  #0, d0
00001208  6000 0006                380      bra     .done
0000120C                           381  
0000120C                           382  .error
0000120C  103C 0001                383      move.b  #1, d0
00001210                           384  
00001210                           385  .done
00001210  4E75                     386      rts
00001212                           387      
00001212                           388  mem_GetSize:
00001212  103C 0000                389      move.b  #0, d0
00001216  2228 FFF8                390      move.l  MEM_OFFSET_GETSIZE(a0), d1
0000121A                           391      
0000121A  4E75                     392      rts
0000121C                           393  
0000121C                           394  MEM_START_HEAP          ds.l    1
00001220                           395  MEM_END_HEAP            ds.l    1
00001224                           396  
00001224                           397  
00001224                           398  
00001224                           399  
00001224                           400  
00001224                           401  
00001224                           402  
00001224                           403  
00001224                           404  
00001224                           405  
00001224                           406  
00001224                           407  
00001224                           408  -------------------- end include --------------------
00001224                           409      INCLUDE     "file.x68"
00001224                           410  
00001224  =00000033                411  FILE_TASK_FOPEN      EQU     51
00001224  =00000034                412  FILE_TASK_FCREATE    EQU     52
00001224  =00000035                413  FILE_TASK_FREAD      EQU     53
00001224  =00000036                414  FILE_TASK_FWRITE     EQU     54
00001224  =00000038                415  FILE_TASK_FCLOSE     EQU     56
00001224                           416  
00001224                           417  FILE_READ_REGS       REG    d2/a2
00001224                           418  
00001224                           419  file_Read
00001224                           420      * Load off d2 to store size
00001224  48E7 2020                421      movem.l  FILE_READ_REGS, -(sp)
00001228                           422      
00001228                           423      * Move d1 into d2 to make room for
00001228                           424      * file handle
00001228  2401                     425      move.l  d1, d2
0000122A                           426  
0000122A                           427      * open the file ---
0000122A                           428      * Uses a1 for file name
0000122A  7033                     429      move.l  #FILE_TASK_FOPEN, d0
0000122C  4E4F                     430      trap    #15
0000122E  4A40                     431      tst.w   d0
00001230  6600 001A                432      bne     .done
00001234                           433      * d1 contains file handle
00001234                           434      
00001234                           435      * Read the file ---
00001234                           436      * a1 buffer address, d2.l number of bytes to read
00001234  103C 0035                437      move.b  #FILE_TASK_FREAD, d0
00001238  224A                     438      move.l  a2, a1  ; move buffer into a1 for trap
0000123A  4E4F                     439      trap    #15
0000123C  4A40                     440      tst.w   d0
0000123E  6600 000C                441      bne     .done
00001242                           442      
00001242                           443      * close the file
00001242  7038                     444      move.l  #FILE_TASK_FCLOSE, d0
00001244  4E4F                     445      trap    #15
00001246  4A40                     446      tst.w   d0
00001248  6700 0002                447      beq     .done
0000124C                           448      
0000124C                           449  .done
0000124C  2202                     450      move.l  d2, d1  ; move number of bytes read into d1
0000124E  4CDF 0404                451      movem.l  (sp)+, FILE_READ_REGS   ; Reload d2
00001252  4E75                     452      rts
00001254                           453  
00001254                           454  file_Write
00001254                           455      * Load off d2 to store size
00001254                           456      * Need to store file handle in d1
00001254  2F02                     457      move.l  d2, -(sp)
00001256  2401                     458      move.l  d1, d2
00001258                           459  
00001258                           460      * open the file ---
00001258                           461      * Uses a1 for file name
00001258  103C 0034                462      move.b  #FILE_TASK_FCREATE, d0
0000125C  4E4F                     463      trap    #15
0000125E  4A40                     464      tst.w   d0
00001260  6600 001A                465      bne     .done
00001264                           466      * d1 contains file handle
00001264                           467          
00001264                           468      * write the words ---
00001264                           469      * Uses a1 for file contents
00001264                           470      * uses d2 for file size (in bytes)
00001264  103C 0036                471      move.b  #FILE_TASK_FWRITE, d0
00001268  224A                     472      move.l  a2, a1
0000126A  4E4F                     473      trap    #15
0000126C  4A40                     474      tst.w   d0
0000126E  6600 000C                475      bne     .done
00001272                           476          
00001272                           477      * close the file
00001272  7038                     478      move.l  #FILE_TASK_FCLOSE, d0
00001274  4E4F                     479      trap    #15
00001276  4A40                     480      tst.w   d0
00001278  6700 0002                481      beq     .done
0000127C                           482      
0000127C                           483  .done
0000127C  241F                     484      move.l  (sp)+, d2   ; Reload d2
0000127E  4E75                     485      rts
00001280                           486      
00001280                           487  
00001280                           488  
00001280                           489  
00001280                           490  
00001280                           491  
00001280                           492  
00001280                           493  -------------------- end include --------------------
00001280                           494      INCLUDE     "bitmap.x68"
00001280                           495      
00001280                           496  BMP_LOAD_REGS       REG     d2/a2-a3
00001280                           497  BMP_DRAW_REGS       REG     d5-d7
00001280                           498  
00001280  =00000280                499  BMP_SCREENWIDTH     EQU     640
00001280  =000001E0                500  BMP_SCREENHEIGHT    EQU     480
00001280                           501  
00001280  =00401000                502  BMP_MAX_FILESIZE    EQU     $401000
00001280  =0000000A                503  BMP_OFFS_PIXELGET   EQU     10
00001280  =00000012                504  BMP_OFFS_IMGWH      EQU     18
00001280  =0000001C                505  BMP_OFFS_BPP        EQU     28
00001280  =00000022                506  BMP_OFFS_SIZE       EQU     34
00001280                           507  
00001280  =00000004                508  BMP_BYTESPERPIX_32  EQU     4
00001280  =00000003                509  BMP_BYTESPERPIX_24  EQU     3
00001280                           510  
00001280  =0000424D                511  BMP_FILESIGN        EQU     $424D
00001280                           512  
00001280                           513  bmp_Load:
00001280                           514      
00001280  48E7 2030                515      movem.l BMP_LOAD_REGS, -(sp)
00001284                           516      
00001284                           517      * save a1 for now
00001284  2449                     518      move.l  a1, a2
00001286                           519      
00001286                           520      * Check file size ---
00001286  B2BC 00401000            521      cmp.l   #BMP_MAX_FILESIZE, d1
0000128C  6E00 006E                522      bgt     .er_size
00001290                           523      
00001290  2001                     524      move.l  d1, d0
00001292  C0BC 00000001            525      and.l   #%00000001, d0
00001298  B0BC 00000001            526      cmp.l   #%00000001, d0
0000129E  6700 0066                527      beq     .er_mem
000012A2                           528      
000012A2                           529      * --- Mem Alloc In
000012A2                           530      * d1.l - Size needed
000012A2                           531      
000012A2  6100 FDF2                532      bsr     mem_Alloc
000012A6  4A00                     533      tst.b   d0
000012A8  6600 005C                534      bne     .er_mem
000012AC                           535      * a0 now has the pointer to buffer in memory
000012AC                           536      
000012AC                           537      * save pointer to buffer for later
000012AC  2648                     538      move.l  a0, a3
000012AE                           539      
000012AE  6100 FF62                540      bsr     mem_GetSize
000012B2                           541      * d1 now has the size again
000012B2                           542      
000012B2                           543      * --- File Read In
000012B2                           544      * a1 - start address of filename
000012B2                           545      * a2 - start address of buffer to read to
000012B2                           546      * d1.l - size of buffer to read
000012B2                           547      
000012B2                           548      * move file name back into a1
000012B2                           549      * move pointer to memory into a2 for file_Read
000012B2  224A                     550      move.l  a2, a1
000012B4  2448                     551      move.l  a0, a2
000012B6                           552      
000012B6  6100 FF6C                553      bsr     file_Read
000012BA  4A00                     554      tst.b   d0
000012BC  6600 0052                555      bne     .er_file
000012C0                           556      * --- File Read Out
000012C0                           557      * a1   - start address of buffer read to (a2)
000012C0                           558      * d1.l - number of bytes read
000012C0                           559      
000012C0                           560      * --- Mem Shrink In
000012C0                           561      * a1 - start address of allocation
000012C0                           562      * d1.l - new size
000012C0  6100 FE7A                563      bsr     mem_Shrink
000012C4  4A00                     564      tst.b   d0
000012C6  6600 003E                565      bne     .er_mem
000012CA                           566      
000012CA                           567      * Process Pixels ---
000012CA                           568      * Restore a1 to pointer to buffer
000012CA  224B                     569      move.l  a3, a1
000012CC                           570      * Get image size
000012CC  2429 0022                571      move.l  BMP_OFFS_SIZE(a1), d2
000012D0  E15A                     572      rol.w   #8, d2
000012D2  4842                     573      swap    d2
000012D4  E15A                     574      rol.w   #8, d2
000012D6                           575      
000012D6                           576      * Get to pixels
000012D6  2229 000A                577      move.l  BMP_OFFS_PIXELGET(a1), d1
000012DA  E159                     578      rol.w   #8, d1
000012DC  4841                     579      swap    d1
000012DE  E159                     580      rol.w   #8, d1
000012E0  D3C1                     581      add.l   d1, a1
000012E2                           582      
000012E2                           583      * Get bound with image size
000012E2  D489                     584      add.l   a1, d2
000012E4                           585      
000012E4                           586      * Loop through pixels
000012E4                           587      
000012E4                           588  .pxl_Loop
000012E4                           589      
000012E4                           590      * Adjust colors
000012E4  2211                     591      move.l  (a1), d1
000012E6  E089                     592      lsr.l   #8, d1
000012E8  2281                     593      move.l  d1, (a1)
000012EA                           594      
000012EA  5889                     595      add.l   #4, a1
000012EC                           596  
000012EC  B3C2                     597      cmp.l   d2, a1
000012EE  6DF4                     598      blt     .pxl_Loop
000012F0                           599      
000012F0                           600      *Restore a1 again
000012F0  224B                     601      move.l  a3, a1
000012F2                           602      
000012F2                           603  .done
000012F2  103C 0000                604      move.b  #0, d0
000012F6  4CDF 0C04                605      movem.l (sp)+, BMP_LOAD_REGS
000012FA  4E75                     606      rts
000012FC                           607      
000012FC                           608  .er_Size
000012FC  103C 0001                609      move.b  #1, d0
00001300  4CDF 0C04                610      movem.l (sp)+, BMP_LOAD_REGS
00001304  4E75                     611      rts
00001306                           612      
00001306                           613  .er_mem
00001306  103C 0002                614      move.b  #2, d0
0000130A  4CDF 0C04                615      movem.l (sp)+, BMP_LOAD_REGS
0000130E  4E75                     616      rts
00001310                           617      
00001310                           618  .er_file
00001310  103C 0003                619      move.b  #3, d0
00001314  4CDF 0C04                620      movem.l (sp)+, BMP_LOAD_REGS
00001318  4E75                     621      rts
0000131A                           622  
0000131A                           623  bmp_Unload:
0000131A                           624      
0000131A                           625      * Check to make sure pointer is in correct place
0000131A  3011                     626      move.w  (a1), d0
0000131C  B07C 424D                627      cmp.w   #BMP_FILESIGN, d0
00001320  6600 0012                628      bne     .er_mem
00001324                           629      
00001324  6100 FDF2                630      bsr     mem_Free
00001328  4A00                     631      tst.b   d0
0000132A  6600 0008                632      bne     .er_mem
0000132E                           633  
0000132E                           634  .done
0000132E  103C 0000                635      move.b  #0, d0
00001332  4E75                     636      rts
00001334                           637  
00001334                           638  .er_mem
00001334  103C 0002                639      move.b  #2, d0
00001338  4E75                     640      rts
0000133A                           641  
0000133A                           642  bmp_DrawTrans:
0000133A  48E7 0700                643      movem.l BMP_DRAW_REGS, -(sp)
0000133E                           644      
0000133E                           645      * Check that we are looking at a bitmap
0000133E  3A11                     646      move.w  (a1), d5
00001340  BA7C 424D                647      cmp.w   #BMP_FILESIGN, d5
00001344  6600 00B0                648      bne     .er_file
00001348                           649      
00001348                           650      * Get pixel offset
00001348  2229 000A                651      move.l  BMP_OFFS_PIXELGET(a1), d1
0000134C  E159                     652      rol.w   #8, d1
0000134E  4841                     653      swap    d1
00001350  E159                     654      rol.w   #8, d1
00001352                           655      
00001352                           656      * Get Image width ---
00001352  2A29 0012                657      move.l  BMP_OFFS_IMGWH(a1), d5
00001356                           658      * Get Image height ---
00001356  5889                     659      add.l   #4, a1
00001358  2C29 0012                660      move.l  BMP_OFFS_IMGWH(a1), d6
0000135C  5989                     661      sub.l   #4, a1
0000135E                           662      
0000135E                           663      * Switch endian-ness
0000135E  E15D                     664      rol.w   #8, d5
00001360  4845                     665      swap    d5
00001362  E15D                     666      rol.w   #8, d5
00001364  E15E                     667      rol.w   #8, d6
00001366  4846                     668      swap    d6
00001368  E15E                     669      rol.w   #8, d6
0000136A                           670      
0000136A                           671      * Calc bytes to subract ---
0000136A  2E05                     672      move.l  d5, d7
0000136C  4844                     673      swap    d4
0000136E  DE44                     674      add.w   d4, d7
00001370  4844                     675      swap    d4
00001372  CEFC 0004                676      mulu.w  #BMP_BYTESPERPIX_32, d7
00001376                           677      
00001376                           678      * Move a1 to pixels (And free d1) ---
00001376  D3C1                     679      add.l   d1, a1
00001378  4281                     680      clr.l   d1          * Unneccessary but easier for debug
0000137A                           681      
0000137A                           682      * Move screen coords into d1 and d2 ---
0000137A                           683      
0000137A                           684      * Get image offset coords ---
0000137A                           685      * (ImageHeight  - starting y)
0000137A  9C43                     686      sub.w   d3, d6
0000137C                           687      
0000137C                           688      * Subtract by 1 if != 0
0000137C  BC7C 0000                689      cmp.w   #0, d6
00001380  6700 0004                690      beq     .zeroRow
00001384  5346                     691      sub.w   #1, d6
00001386                           692      
00001386                           693  .zeroRow
00001386                           694      * multiply by Image Width
00001386  CCC5                     695      mulu.w  d5, d6      * d5 no longer needed
00001388  4285                     696      clr.l   d5
0000138A                           697      
0000138A                           698      * Add starting x
0000138A  4843                     699      swap    d3
0000138C  3A03                     700      move.w  d3, d5
0000138E  DC85                     701      add.l   d5, d6      
00001390  E586                     702      asl.l   #2, d6  * Multiply by 4, for 32 bit
00001392  D3C6                     703      add.l   d6, a1
00001394  4285                     704      clr.l   d5
00001396                           705      
00001396                           706      * Calc Bounds ---
00001396                           707      * Move width and height into
00001396                           708      * d4 High word - Rect Height
00001396                           709      * d4 Low word - Rect Width
00001396  4844                     710      swap    d4
00001398  3A04                     711      move.w  d4, d5
0000139A                           712      
0000139A                           713      * Add starting points (if not zero)
0000139A  4842                     714      swap    d2
0000139C  B47C 0000                715      cmp.w   #0, d2
000013A0  6700 0004                716      beq     .zeroX
000013A4  D842                     717      add.w   d2, d4
000013A6                           718      
000013A6                           719  .zeroX
000013A6  4842                     720      swap    d2
000013A8  B47C 0000                721      cmp.w   #0, d2
000013AC  6700 0008                722      beq     .zeroY
000013B0  4844                     723      swap    d4
000013B2  D842                     724      add.w   d2, d4
000013B4  4844                     725      swap    d4
000013B6                           726      
000013B6                           727  .zeroY
000013B6                           728      * Swap because you swap in rowLoop
000013B6  4844                     729      swap    d4
000013B8                           730      
000013B8                           731          
000013B8                           732      * d0 needed for trap codes
000013B8                           733      * Pen color needs to be in d1
000013B8                           734      * screen coords need to be in d1 and d2
000013B8                           735      * -- d3 will hold d1 when context switching
000013B8                           736      * -- d6 will hold the color offset
000013B8                           737  .rowLoop_32
000013B8                           738      * Swap back to get width
000013B8  4844                     739      swap    d4
000013BA  4842                     740      swap    d2
000013BC                           741  .colLoop_32
000013BC                           742  
000013BC                           743      * Get color ---
000013BC                           744      * Rotate for ABGR
000013BC                           745      * Get next color
000013BC  2211                     746      move.l  (a1), d1
000013BE  B2BC 00000000            747      cmp.l   #0, d1
000013C4  6700 0010                748      beq     .incCol_32
000013C8                           749      
000013C8                           750      * Set Pen Color
000013C8  7050                     751      move.l  #80, d0
000013CA  4E4F                     752      trap    #15
000013CC                           753      
000013CC                           754      * Reset screen coord x
000013CC  3202                     755      move.w  d2, d1
000013CE  4842                     756      swap    d2
000013D0                           757      
000013D0                           758      * Draw Pixel ---
000013D0  7052                     759      move.l  #82, d0
000013D2  4E4F                     760      trap    #15
000013D4                           761      
000013D4  4842                     762      swap    d2
000013D6                           763      
000013D6                           764  .incCol_32
000013D6                           765      * Move screen coord col (x) ---
000013D6  5242                     766      add.w   #1, d2
000013D8  5889                     767      add.l  #4, a1
000013DA                           768      
000013DA  B444                     769      cmp.w   d4, d2
000013DC  6DDE                     770      blt     .colLoop_32
000013DE                           771      * Closes colLoop ======================
000013DE                           772      
000013DE                           773      * Clear screen coord col (x) ---
000013DE  9445                     774      sub.w   d5, d2
000013E0                           775      
000013E0                           776      * Move offset backwards ---
000013E0  93C7                     777      sub.l   d7, a1
000013E2                           778      
000013E2                           779      * Move screen coord row (y) ---
000013E2  4842                     780      swap    d2
000013E4  5242                     781      add.w   #1, d2
000013E6                           782      
000013E6                           783      * Get High word (Rect Height)
000013E6  4844                     784      swap    d4
000013E8                           785      
000013E8  B444                     786      cmp.w   d4, d2
000013EA  6DCC                     787      blt     .rowLoop_32
000013EC                           788      * Closes rowLoop =====================
000013EC                           789      
000013EC  103C 0000                790      move.b  #0, d0
000013F0  4CDF 00E0                791      movem.l (sp)+, BMP_DRAW_REGS
000013F4  4E75                     792      rts
000013F6                           793  
000013F6                           794      
000013F6                           795  .er_file
000013F6  103C 0001                796      move.b  #1, d0
000013FA  4CDF 00E0                797      movem.l (sp)+, BMP_DRAW_REGS
000013FE  4E75                     798      rts
00001400                           799      
00001400                           800  .er_bounds
00001400  103C 0002                801      move.b  #2, d0
00001404  4CDF 00E0                802      movem.l (sp)+, BMP_DRAW_REGS
00001408  4E75                     803      rts
0000140A                           804      
0000140A                           805  bmp_Draw:
0000140A  48E7 0700                806      movem.l BMP_DRAW_REGS, -(sp)
0000140E                           807      
0000140E                           808      * Check that we are looking at a bitmap
0000140E  3A11                     809      move.w  (a1), d5
00001410  BA7C 424D                810      cmp.w   #BMP_FILESIGN, d5
00001414  6600 00A6                811      bne     .er_file
00001418                           812      
00001418                           813      * Get to pixel offset
00001418  2229 000A                814      move.l  BMP_OFFS_PIXELGET(a1), d1
0000141C  E159                     815      rol.w   #8, d1
0000141E  4841                     816      swap    d1
00001420  E159                     817      rol.w   #8, d1
00001422                           818      
00001422                           819      * Get Image width ---
00001422  2A29 0012                820      move.l  BMP_OFFS_IMGWH(a1), d5
00001426                           821      * Get Image height ---
00001426  5889                     822      add.l   #4, a1
00001428  2C29 0012                823      move.l  BMP_OFFS_IMGWH(a1), d6
0000142C  5989                     824      sub.l   #4, a1
0000142E                           825      
0000142E                           826      * Switch endian-ness
0000142E  E15D                     827      rol.w   #8, d5
00001430  4845                     828      swap    d5
00001432  E15D                     829      rol.w   #8, d5
00001434  E15E                     830      rol.w   #8, d6
00001436  4846                     831      swap    d6
00001438  E15E                     832      rol.w   #8, d6
0000143A                           833      
0000143A                           834      * Calc bytes to subract ---
0000143A  2E05                     835      move.l  d5, d7
0000143C  4844                     836      swap    d4
0000143E  DE44                     837      add.w   d4, d7
00001440  4844                     838      swap    d4
00001442  CEFC 0004                839      mulu.w  #BMP_BYTESPERPIX_32, d7
00001446                           840      
00001446                           841      * Move a1 to pixels (And free d1) ---
00001446  D3C1                     842      add.l   d1, a1
00001448  4281                     843      clr.l   d1          * Unneccessary but easier for debug
0000144A                           844      
0000144A                           845      * Move screen coords into d1 and d2 ---
0000144A                           846      
0000144A                           847      * Get image offset coords ---
0000144A                           848      * (ImageHeight  - starting y)
0000144A  9C43                     849      sub.w   d3, d6
0000144C                           850      
0000144C                           851      * Subtract by 1 if != 0
0000144C  BC7C 0000                852      cmp.w   #0, d6
00001450  6700 0004                853      beq     .zeroRow
00001454  5346                     854      sub.w   #1, d6
00001456                           855      
00001456                           856  .zeroRow
00001456                           857      * multiply by Image Width
00001456  CCC5                     858      mulu.w  d5, d6      * d5 no longer needed
00001458  4285                     859      clr.l   d5
0000145A                           860      
0000145A                           861      * Add starting x
0000145A  4843                     862      swap    d3
0000145C  3A03                     863      move.w  d3, d5
0000145E  DC85                     864      add.l   d5, d6      
00001460  E586                     865      asl.l   #2, d6  * Multiply by 4, for 32 bit
00001462  D3C6                     866      add.l   d6, a1
00001464  4285                     867      clr.l   d5
00001466                           868      
00001466                           869      * Calc Bounds ---
00001466                           870      * Move width and height into
00001466                           871      * d4 High word - Rect Height
00001466                           872      * d4 Low word - Rect Width
00001466  4844                     873      swap    d4
00001468  3A04                     874      move.w  d4, d5
0000146A                           875      
0000146A                           876      * Add starting points (if not zero)
0000146A  4842                     877      swap    d2
0000146C  B47C 0000                878      cmp.w   #0, d2
00001470  6700 0004                879      beq     .zeroX
00001474  D842                     880      add.w   d2, d4
00001476                           881      
00001476                           882  .zeroX
00001476  4842                     883      swap    d2
00001478  B47C 0000                884      cmp.w   #0, d2
0000147C  6700 0008                885      beq     .zeroY
00001480  4844                     886      swap    d4
00001482  D842                     887      add.w   d2, d4
00001484  4844                     888      swap    d4
00001486                           889      
00001486                           890  .zeroY
00001486                           891      * Swap because you swap in rowLoop
00001486  4844                     892      swap    d4
00001488                           893      
00001488                           894      * Now multiply by bit depth and switch to correct draw loop
00001488                           895      
00001488                           896          
00001488                           897      * d0 needed for trap codes
00001488                           898      * Pen color needs to be in d1
00001488                           899      * screen coords need to be in d1 and d2
00001488                           900      * -- d3 will hold d1 when context switching
00001488                           901      * -- d6 will hold the color offset
00001488                           902  .rowLoop_32
00001488                           903      * Swap back to get width
00001488  4844                     904      swap    d4
0000148A  4842                     905      swap    d2
0000148C                           906  .colLoop_32
0000148C                           907  
0000148C                           908      * Get color ---
0000148C                           909      * Rotate for ABGR
0000148C                           910      * Get next color
0000148C  2211                     911      move.l  (a1), d1
0000148E                           912      
0000148E                           913      * Set Pen Color
0000148E  7050                     914      move.l  #80, d0
00001490  4E4F                     915      trap    #15
00001492                           916      
00001492                           917      * Reset screen coord x
00001492  3202                     918      move.w  d2, d1
00001494  4842                     919      swap    d2
00001496                           920      
00001496                           921      * Draw Pixel ---
00001496  7052                     922      move.l  #82, d0
00001498  4E4F                     923      trap    #15
0000149A                           924      
0000149A  4842                     925      swap    d2
0000149C                           926      
0000149C  5242                     927      add.w   #1, d2
0000149E  5889                     928      add.l  #4, a1
000014A0                           929      
000014A0  B444                     930      cmp.w   d4, d2
000014A2  6DE8                     931      blt     .colLoop_32
000014A4                           932      * Closes colLoop ======================
000014A4                           933      
000014A4                           934      * Clear screen coord col (x) ---
000014A4  9445                     935      sub.w   d5, d2
000014A6                           936      
000014A6                           937      * Move offset backwards ---
000014A6  93C7                     938      sub.l   d7, a1
000014A8                           939      
000014A8                           940      * Move screen coord row (y) ---
000014A8  4842                     941      swap    d2
000014AA  5242                     942      add.w   #1, d2
000014AC                           943      
000014AC                           944      * Get High word (Rect Height)
000014AC  4844                     945      swap    d4
000014AE                           946      
000014AE  B444                     947      cmp.w   d4, d2
000014B0  6DD6                     948      blt     .rowLoop_32
000014B2                           949      * Closes rowLoop =====================
000014B2                           950      
000014B2  103C 0000                951      move.b  #0, d0
000014B6  4CDF 00E0                952      movem.l (sp)+, BMP_DRAW_REGS
000014BA  4E75                     953      rts
000014BC                           954  
000014BC                           955      
000014BC                           956  .er_file
000014BC  103C 0001                957      move.b  #1, d0
000014C0  4CDF 00E0                958      movem.l (sp)+, BMP_DRAW_REGS
000014C4  4E75                     959      rts
000014C6                           960      
000014C6                           961  .er_bounds
000014C6  103C 0002                962      move.b  #2, d0
000014CA  4CDF 00E0                963      movem.l (sp)+, BMP_DRAW_REGS
000014CE  4E75                     964      rts
000014D0                           965  
000014D0                           966  
000014D0                           967  bmp_Endian:
000014D0                           968      
000014D0                           969      *---
000014D0                           970      * 03 02 01 00
000014D0                           971      * 03 02 00 01 Rotate.w #8, d1
000014D0                           972      * 00 01 03 02 Swap     d1
000014D0                           973      * 00 01 02 03 Rotate.w #8, d1
000014D0                           974      *---
000014D0                           975      
000014D0  E159                     976      rol.w   #8, d1
000014D2  4841                     977      swap    d1
000014D4  E159                     978      rol.w   #8, d1
000014D6                           979      
000014D6  4E75                     980      rts
000014D8                           981  
000014D8                           982  
000014D8                           983  
000014D8                           984  
000014D8                           985  
000014D8                           986  
000014D8                           987  
000014D8                           988  
000014D8                           989  
000014D8                           990  
000014D8                           991  
000014D8                           992  
000014D8                           993  
000014D8                           994  
000014D8                           995  -------------------- end include --------------------
000014D8                           996      INCLUDE     "object.x68"
000014D8                           997  
000014D8                           998  
000014D8                           999  OBJ_INIT_REGS               REG d0-d2/a1
000014D8                          1000  OBJ_DRAW_REGS               REG d2-d4
000014D8                          1001  OBJ_COLLIDE_REGS            REG d2-d4
000014D8                          1002  
000014D8                          1003  
000014D8  =00000000               1004  OBJ_OFFS_SCREENCOORDS       EQU 0
000014D8  =00000004               1005  OBJ_OFFS_BMPCOORDS          EQU 4
000014D8  =00000008               1006  OBJ_OFFS_BMPSIZE            EQU 8
000014D8  =0000000C               1007  OBJ_OFFS_BMPADD             EQU 12
000014D8  =00000010               1008  OBJ_OFFS_CENTER             EQU 16
000014D8  =00000014               1009  OBJ_OFFS_CORNER             EQU 20
000014D8  =00000018               1010  OBJ_HEADER_SIZE             EQU 24 * !!! update this value based on your header layout
000014D8                          1011  
000014D8                          1012  OBJ_init:
000014D8                          1013      
000014D8                          1014      * Allocate Space
000014D8  48E7 E040               1015      movem.l  OBJ_INIT_REGS, -(sp)
000014DC                          1016      
000014DC  7218                    1017      move.l  #OBJ_HEADER_SIZE, d1
000014DE                          1018      
000014DE  6100 FBB6               1019      bsr     mem_Alloc
000014E2  4A00                    1020      tst.b   d0
000014E4  6600 0038               1021      bne     .error
000014E8                          1022      
000014E8  4CDF 0207               1023      movem.l  (sp)+, OBJ_INIT_REGS
000014EC                          1024      
000014EC                          1025      * Fill in values
000014EC  2142 0000               1026      move.l  d2, OBJ_OFFS_SCREENCOORDS(a0)
000014F0  2140 0004               1027      move.l  d0, OBJ_OFFS_BMPCOORDS(a0)
000014F4  2141 0008               1028      move.l  d1, OBJ_OFFS_BMPSIZE(a0)
000014F8  2149 000C               1029      move.l  a1, OBJ_OFFS_BMPADD(a0)
000014FC                          1030      
000014FC                          1031      * Find corner and fill in value
000014FC  D441                    1032      add.w   d1, d2
000014FE  4841                    1033      swap    d1
00001500  4842                    1034      swap    d2
00001502  D441                    1035      add.w   d1, d2
00001504  4841                    1036      swap    d1
00001506  4842                    1037      swap    d2
00001508  2142 0014               1038      move.l  d2, OBJ_OFFS_CORNER(a0)
0000150C                          1039      
0000150C                          1040      * Find center and fill in value
0000150C  E249                    1041      lsr.w   #1, d1
0000150E  4841                    1042      swap    d1
00001510  E249                    1043      lsr.w   #1, d1
00001512  4841                    1044      swap    d1
00001514                          1045      
00001514  2141 0010               1046      move.l  d1, OBJ_OFFS_CENTER(a0)
00001518                          1047  
00001518                          1048  .done
00001518  103C 0000               1049      move.b  #0, d0
0000151C  4E75                    1050      rts
0000151E                          1051      
0000151E                          1052  .error
0000151E  4CDF 0207               1053      movem.l  (sp)+, OBJ_INIT_REGS
00001522  103C 0001               1054      move.b  #1, d0
00001526  4E75                    1055      rts
00001528                          1056  
00001528                          1057  OBJ_setCoords:
00001528  2140 0000               1058      move.l  d0, OBJ_OFFS_SCREENCOORDS(a0)
0000152C  2228 0008               1059      move.l  OBJ_OFFS_BMPSIZE(a0), d1
00001530                          1060      
00001530  D041                    1061      add.w   d1, d0
00001532  4841                    1062      swap    d1
00001534  4840                    1063      swap    d0
00001536  D041                    1064      add.w   d1, d0
00001538  4841                    1065      swap    d1
0000153A  4840                    1066      swap    d0
0000153C  2140 0014               1067      move.l  d0, OBJ_OFFS_CORNER(a0)
00001540  4E75                    1068      rts
00001542                          1069  
00001542                          1070  OBJ_getCoords:
00001542  2028 0000               1071      move.l  OBJ_OFFS_SCREENCOORDS(a0), d0
00001546  4E75                    1072      rts
00001548                          1073  
00001548                          1074  OBJ_draw:
00001548  48E7 3800               1075      movem.l OBJ_DRAW_REGS, -(sp)
0000154C                          1076      
0000154C                          1077      * --- BMP_DRAW
0000154C                          1078      * a1 - address of loaded BMP
0000154C                          1079      * d2.l - Point in screen coordinates to start
0000154C                          1080      * d3.l - Rect starting point (x, y)
0000154C                          1081      * d4.l - Rect (Width, Height)
0000154C  2268 000C               1082      move.l  OBJ_OFFS_BMPADD(a0), a1
00001550  2428 0000               1083      move.l  OBJ_OFFS_SCREENCOORDS(a0), d2
00001554  2628 0004               1084      move.l  OBJ_OFFS_BMPCOORDS(a0), d3
00001558  2828 0008               1085      move.l  OBJ_OFFS_BMPSIZE(a0), d4
0000155C                          1086      
0000155C  4EB8 133A               1087      jsr     bmp_DrawTrans
00001560                          1088  
00001560                          1089  .done
00001560  4CDF 001C               1090      movem.l (sp)+, OBJ_DRAW_REGS
00001564  103C 0000               1091      move.b  #0, d0
00001568  4E75                    1092      rts
0000156A                          1093      
0000156A                          1094  .error
0000156A  4CDF 001C               1095      movem.l (sp)+, OBJ_DRAW_REGS
0000156E  103C 0001               1096      move.b  #1, d0
00001572  4E75                    1097      rts
00001574                          1098      
00001574                          1099  OBJ_Collide:
00001574  48E7 3800               1100      movem.l OBJ_COLLIDE_REGS, -(sp)
00001578                          1101      
00001578  2428 0008               1102      move.l  OBJ_OFFS_BMPSIZE(a0), d2        ;a0(x+w, y+h)
0000157C  D440                    1103      add.w   d0, d2
0000157E  4840                    1104      swap    d0
00001580  4842                    1105      swap    d2
00001582  D440                    1106      add.w   d0, d2
00001584  4840                    1107      swap    d0
00001586  4842                    1108      swap    d2
00001588                          1109  
00001588  2229 0000               1110      move.l  OBJ_OFFS_SCREENCOORDS(a1), d1   ;a1(x, y)
0000158C  2629 0014               1111      move.l  OBJ_OFFS_CORNER(a1), d3        ;a1(x+w, y+h)
00001590                          1112      
00001590                          1113      * If a1(y) > a0(y+h) no collide!
00001590  B242                    1114      cmp.w   d2, d1
00001592  6E00 0026               1115      bgt     .no_Collide
00001596                          1116      
00001596                          1117      * If a1(y+h) < a0(y) no collide!
00001596  B640                    1118      cmp.w   d0, d3
00001598  6D00 0020               1119      blt     .no_Collide
0000159C                          1120      
0000159C  4840                    1121      swap    d0
0000159E  4841                    1122      swap    d1
000015A0  4842                    1123      swap    d2
000015A2  4843                    1124      swap    d3
000015A4                          1125      
000015A4                          1126      * If a1(x) > a0(x+w) no collide!
000015A4  B242                    1127      cmp.w   d2, d1
000015A6  6E00 0012               1128      bgt     .no_Collide
000015AA                          1129      
000015AA                          1130      * If a1(x+w) < a0(x) no collide!
000015AA  B640                    1131      cmp.w   d0, d3
000015AC  6D00 000C               1132      blt     .no_Collide
000015B0                          1133  
000015B0                          1134  .collide
000015B0  4CDF 001C               1135      movem.l (sp)+, OBJ_COLLIDE_REGS
000015B4  103C 0000               1136      move.b  #0, d0
000015B8  4E75                    1137      rts
000015BA                          1138      
000015BA                          1139  .no_Collide
000015BA  4CDF 001C               1140      movem.l (sp)+, OBJ_COLLIDE_REGS
000015BE  103C 0001               1141      move.b  #1, d0
000015C2  4E75                    1142      rts
000015C4                          1143  
000015C4                          1144  -------------------- end include --------------------
000015C4                          1145      
000015C4  =0000000D               1146  TASK_PRINT                  EQU     13
000015C4  =DEADDEAD               1147  SENTINEL                    EQU     $deaddead
000015C4                          1148  
000015C4                          1149  DRAWRECT                    REG     d2-d4
000015C4                          1150  DRAWBMP                     REG     d2-d4
000015C4                          1151  
000015C4  =00300000               1152  HEAP_BYTES                  EQU     $300000
000015C4                          1153  
000015C4  =41445357               1154  WASD_CODES                  EQU     $41445357
000015C4                          1155  
000015C4  =00000000               1156  W_CHECKBIT                  EQU     0
000015C4  =00000018               1157  A_CHECKBIT                  EQU     24
000015C4  =00000008               1158  S_CHECKBIT                  EQU     8
000015C4  =00000010               1159  D_CHECKBIT                  EQU     16
000015C4                          1160  
000015C4  =00FFFFFF               1161  WHITECOLOR                  EQU     $00FFFFFF
000015C4  =00000000               1162  BLACKCOLOR                  EQU     $00000000
000015C4                          1163  
000015C4  =0000000A               1164  MOVE                        EQU     10
000015C4                          1165  
000015C4  =00000017               1166  DELAY_FRAME                 EQU     23
000015C4  =00000002               1167  FRAME_DELAY_TIME            EQU     2
000015C4  =0000005C               1168  DRAWING_MODE_TRAP_CODE      EQU     92
000015C4  =00000011               1169  DOUBLE_BUFFERED_MODE        EQU     17
000015C4  =0000005E               1170  REPAINT_SCREEN_TRAP_CODE    EQU     94
000015C4                          1171  
000015C4                          1172  START:                  ; first instruction of program
000015C4                          1173  
000015C4                          1174      * d2 - Player position
000015C4                          1175      * a2 - Player object address
000015C4                          1176  
000015C4                          1177      * Set double buffering to true
000015C4                          1178  *    move.b #DRAWING_MODE_TRAP_CODE,d0
000015C4                          1179  *    move.b #DOUBLE_BUFFERED_MODE,d1
000015C4                          1180  *    trap   #15
000015C4                          1181  
000015C4                          1182      * Initialize Heap
000015C4  43F9 000017CE           1183      lea     StartOfMem, a1
000015CA  223C 00300000           1184      move.l  #HEAP_BYTES, d1
000015D0  6100 FA2E               1185      bsr     mem_InitHeap
000015D4  4A00                    1186      tst.b   d0
000015D6  6600 00B2               1187      bne     .error
000015DA                          1188      
000015DA                          1189      * Load Background ---
000015DA  43F9 000017A1           1190      lea     Background, a1
000015E0  223C 0012C046           1191      move.l  #$12C046, d1
000015E6  6100 FC98               1192      bsr     bmp_Load
000015EA  4A00                    1193      tst.b   d0
000015EC  6600 009C               1194      bne     .error
000015F0                          1195      
000015F0  41F9 000017B2           1196      lea     BackgroundData, a0
000015F6  2089                    1197      move.l  a1, (a0)
000015F8  2141 0004               1198      move.l  d1, 4(a0)
000015FC                          1199      
000015FC                          1200      * Draw Background ---
000015FC                          1201      * d2.l - Point in screen coordinates to start
000015FC                          1202      * d3.l - Rect starting point (x, y)
000015FC                          1203      * d4.l - Rect (Width, Height)
000015FC  4282                    1204      clr.l   d2
000015FE  4283                    1205      clr.l   d3
00001600  283C 028001E0           1206      move.l  #$028001E0, d4
00001606  6100 FE02               1207      bsr     bmp_Draw
0000160A  4A00                    1208      tst.b   d0
0000160C  6600 007C               1209      bne     .error
00001610                          1210  
00001610                          1211      * Create Player Object ---
00001610                          1212      * Load BMP
00001610  43F9 000017BA           1213      lea     UFO, a1
00001616  223C 00002000           1214      move.l  #$2000, d1
0000161C  6100 FC62               1215      bsr     bmp_Load
00001620  4A00                    1216      tst.b   d0
00001622  6600 0066               1217      bne     .error
00001626                          1218      
00001626  2649                    1219      move.l  a1, a3
00001628                          1220      
00001628                          1221      * Obj Init
00001628                          1222      *   - d0.l  - Rect Coordinates
00001628                          1223      *   - d1.l  - BMP Size
00001628                          1224      *   - d2.l  - Screen Coordinates
00001628                          1225      *   - a1    - BMP Address
00001628  4280                    1226      clr.l   d0
0000162A  223C 002A001E           1227      move.l  #$002A001E, d1
00001630  343C 0064               1228      move.w  #100, d2
00001634  4842                    1229      swap    d2
00001636  343C 0064               1230      move.w  #100, d2
0000163A  4EB8 14D8               1231      jsr     OBJ_init
0000163E                          1232      
0000163E                          1233      * Save off Player Object
0000163E  2448                    1234      move.l  a0, a2
00001640                          1235      
00001640  4EB8 1548               1236      jsr     OBJ_draw
00001644                          1237      
00001644                          1238      * Create Sample Player for Collision test ---
00001644                          1239      * Obj Init
00001644                          1240      *   - d0.l  - Rect Coordinates
00001644                          1241      *   - d1.l  - BMP Size
00001644                          1242      *   - d2.l  - Screen Coordinates
00001644                          1243      *   - a1    - BMP Address
00001644  4280                    1244      clr.l   d0
00001646  223C 002A001E           1245      move.l  #$002A001E, d1
0000164C  343C 0190               1246      move.w  #400, d2
00001650  4842                    1247      swap    d2
00001652  343C 0190               1248      move.w  #400, d2
00001656  224B                    1249      move.l  a3, a1
00001658  4EB8 14D8               1250      jsr     OBJ_init
0000165C                          1251      
0000165C                          1252      * Save off new object
0000165C  23C8 000017C8           1253      move.l  a0, (ObjArray)
00001662                          1254      
00001662  4EB8 1548               1255      jsr     OBJ_draw
00001666                          1256      
00001666  243C 00640064           1257      move.l  #$00640064, d2    
0000166C                          1258  .gameLoop
0000166C                          1259      
0000166C                          1260      * Uses d4 for input handling
0000166C  6100 002A               1261      bsr     handle_Input
00001670                          1262      
00001670  6100 0106               1263      bsr     delayFrame
00001674  4EB9 00001780           1264      jsr     swapBuffers
0000167A                          1265      
0000167A  1039 000017CC           1266      move.b  GAMERUNNING, d0
00001680  B03C 0000               1267      cmp.b   #0, d0
00001684  66E6                    1268      bne     .gameLoop
00001686  6000 000C               1269      bra     .done
0000168A                          1270      
0000168A                          1271  .error
0000168A  700D                    1272      moveq   #TASK_PRINT, d0
0000168C  43F9 00001788           1273      lea     ErrorLabel, a1
00001692  4E4F                    1274      trap    #15
00001694                          1275  
00001694                          1276  .done
00001694                          1277  
00001694  FFFF FFFF               1278      SIMHALT             ; halt simulator
00001698                          1279      
00001698                          1280  * === Subroutines ===
00001698                          1281  
00001698                          1282  handle_Input:
00001698                          1283  
00001698                          1284      * Get Input ---
00001698                          1285      * Get keys pressed
00001698  103C 0013               1286      move.b  #19, d0
0000169C  223C 41445357           1287      move.l  #WASD_CODES, d1
000016A2  4E4F                    1288      trap    #15
000016A4  2801                    1289      move.l  d1, d4
000016A6                          1290      * Now d4 has $FF in bytes where keys were pressed
000016A6                          1291      
000016A6  B8BC 00000000           1292      cmp.l   #0, d4
000016AC  6700 0060               1293      beq     .done
000016B0                          1294      
000016B0  6100 0090               1295      bsr     DrawBehind
000016B4                          1296      
000016B4  204A                    1297      move.l  a2, a0
000016B6                          1298      
000016B6                          1299      * Check keys down
000016B6  0804 0000               1300      btst.l  #W_CHECKBIT, d4
000016BA  6700 0006               1301      beq     .checkS
000016BE                          1302  
000016BE                          1303      * if not equal, w pressed
000016BE  0442 000A               1304      sub.w   #MOVE, d2
000016C2                          1305      
000016C2                          1306  .checkS
000016C2  0804 0008               1307      btst.l  #S_CHECKBIT, d4
000016C6  6700 0006               1308      beq     .checkA
000016CA                          1309      
000016CA                          1310      * if not equal, s pressed
000016CA  0642 000A               1311      add.w   #MOVE, d2
000016CE                          1312  
000016CE                          1313  .checkA
000016CE  4842                    1314      swap    d2
000016D0  0804 0018               1315      btst.l  #A_CHECKBIT, d4
000016D4  6700 0006               1316      beq     .checkD
000016D8                          1317      
000016D8                          1318     * if not equal, a pressed
000016D8  0442 000A               1319      sub.w   #MOVE, d2
000016DC                          1320      
000016DC                          1321  .checkD
000016DC  0804 0010               1322      btst.l  #D_CHECKBIT, d4
000016E0  6700 0006               1323      beq     .collision
000016E4                          1324      
000016E4                          1325      * if not equal, d pressed
000016E4  0642 000A               1326      add.w   #MOVE, d2    
000016E8                          1327  
000016E8                          1328  .collision
000016E8                          1329      
000016E8                          1330      * Handle Collisions
000016E8  4842                    1331      swap    d2
000016EA  2002                    1332      move.l  d2, d0
000016EC  204A                    1333      move.l  a2, a0
000016EE  2279 000017C8           1334      move.l  (ObjArray), a1
000016F4  4EB8 1574               1335      jsr     OBJ_Collide
000016F8  4A00                    1336      tst.b   d0
000016FA  6600 0008               1337      bne     .draw
000016FE                          1338      
000016FE  4EB8 1542               1339      jsr     OBJ_getCoords
00001702  2400                    1340      move.l  d0, d2
00001704                          1341      
00001704                          1342  .draw
00001704  2002                    1343      move.l  d2, d0
00001706  6100 FE20               1344      bsr     OBJ_setCoords
0000170A                          1345      
0000170A  6100 FE3C               1346      bsr     OBJ_draw
0000170E                          1347      
0000170E                          1348  .done
0000170E  103C 0000               1349      move.b  #0, d0
00001712  4E75                    1350      rts
00001714                          1351      
00001714                          1352  .error
00001714  103C 0001               1353      move.b  #1, d0
00001718  4E75                    1354      rts
0000171A                          1355  
0000171A                          1356  * = Draw Rectangle =
0000171A                          1357  * - In
0000171A                          1358  * --- d1.l - Draw color
0000171A                          1359  * --- d2.w - left x
0000171A                          1360  * --- d3.w - top y
0000171A                          1361  * 
0000171A                          1362  * - Out
0000171A                          1363  * --- d0.b - Success(0)/Failure(nonzero)
0000171A                          1364  draw_Rect:
0000171A  48E7 3800               1365      movem.l DRAWRECT, -(sp)
0000171E                          1366      
0000171E                          1367      * Set pen color
0000171E  103C 0050               1368      move.b  #80, d0
00001722  4E4F                    1369      trap    #15
00001724                          1370          
00001724                          1371      * Calculate bottom right based on width/height of 50px
00001724  3202                    1372      move.w  d2, d1
00001726  3403                    1373      move.w  d3, d2
00001728  3601                    1374      move.w  d1, d3
0000172A  0643 0032               1375      add.w   #50, d3
0000172E  3802                    1376      move.w  d2, d4
00001730  0644 0032               1377      add.w   #50, d4
00001734                          1378      
00001734  7057                    1379      move.l  #87, d0
00001736  4E4F                    1380      trap    #15
00001738                          1381      
00001738  4CDF 001C               1382      movem.l (sp)+, DRAWRECT
0000173C  103C 0000               1383      move.b  #0, d0
00001740  4E75                    1384      rts
00001742                          1385  
00001742                          1386  DrawBehind:
00001742  48E7 3800               1387      movem.l DRAWBMP, -(sp)
00001746  41F9 000017B2           1388      lea     BackgroundData, a0
0000174C  2250                    1389      move.l  (a0), a1
0000174E  2228 0004               1390      move.l  4(a0), d1
00001752  2602                    1391      move.l  d2, d3
00001754  283C 002A001E           1392      move.l  #$002A001E, d4
0000175A                          1393      
0000175A                          1394      * Draw BMP
0000175A  6100 FCAE               1395      bsr     bmp_Draw
0000175E  4A00                    1396      tst.b   d0
00001760  6600 000C               1397      bne     .error
00001764                          1398  
00001764                          1399  .done
00001764  4CDF 001C               1400      movem.l (sp)+, DRAWBMP
00001768  103C 0000               1401      move.b  #0, d0
0000176C  4E75                    1402      rts
0000176E                          1403      
0000176E                          1404  .error
0000176E  4CDF 001C               1405      movem.l (sp)+, DRAWBMP
00001772  103C 0001               1406      move.b  #1, d0
00001776  4E75                    1407      rts
00001778                          1408  
00001778                          1409      
00001778                          1410  delayFrame:
00001778  7017                    1411          move.l  #DELAY_FRAME, d0
0000177A  7202                    1412          move.l  #FRAME_DELAY_TIME, d1
0000177C  4E4F                    1413          TRAP    #15
0000177E  4E75                    1414          rts
00001780                          1415          
00001780                          1416  swapBuffers:
00001780  103C 005E               1417      move.b  #REPAINT_SCREEN_TRAP_CODE,d0
00001784  4E4F                    1418      trap    #15
00001786  4E75                    1419      rts     
00001788                          1420  
00001788                          1421  * === Static Memory ===
00001788= 41 6E 20 65 72 72 ...   1422  ErrorLabel      dc.b    'An error was encountered',0
000017A1= 42 4D 50 53 2F 47 ...   1423  Background      dc.b    'BMPS/Galaxy.bmp',0
000017B2                          1424  BackgroundData  ds.l    2
000017BA= 42 4D 50 53 2F 55 ...   1425  UFO             dc.b    'BMPS/UFO.bmp',0
000017C7                          1426  
000017C8                          1427  ObjArray        ds.l    1   ; Holds addresses to 4 objs
000017CC                          1428  
000017CC= 01                      1429  GAMERUNNING     dc.b    1
000017CD                          1430  
000017CD                          1431              * longword aligned memory buffer
000017CE                          1432                  ds.l    0
000017CE                          1433  StartOfMem
000017CE= 00 00 00 00 00 00 ...   1434                  dcb.b   HEAP_BYTES,0
003017CE                          1435  EndOfMem
003017CE= DEADDEAD                1436                  dc.l    SENTINEL
003017D2                          1437  
003017D2                          1438      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A_CHECKBIT          18
BACKGROUND          17A1
BACKGROUNDDATA      17B2
BLACKCOLOR          0
BMP_BYTESPERPIX_24  3
BMP_BYTESPERPIX_32  4
BMP_DRAW            140A
BMP_DRAW:COLLOOP_32  148C
BMP_DRAW:ER_BOUNDS  14C6
BMP_DRAW:ER_FILE    14BC
BMP_DRAW:ROWLOOP_32  1488
BMP_DRAW:ZEROROW    1456
BMP_DRAW:ZEROX      1476
BMP_DRAW:ZEROY      1486
BMP_DRAWTRANS       133A
BMP_DRAWTRANS:COLLOOP_32  13BC
BMP_DRAWTRANS:ER_BOUNDS  1400
BMP_DRAWTRANS:ER_FILE  13F6
BMP_DRAWTRANS:INCCOL_32  13D6
BMP_DRAWTRANS:ROWLOOP_32  13B8
BMP_DRAWTRANS:ZEROROW  1386
BMP_DRAWTRANS:ZEROX  13A6
BMP_DRAWTRANS:ZEROY  13B6
BMP_DRAW_REGS       E0
BMP_ENDIAN          14D0
BMP_FILESIGN        424D
BMP_LOAD            1280
BMP_LOAD:DONE       12F2
BMP_LOAD:ER_FILE    1310
BMP_LOAD:ER_MEM     1306
BMP_LOAD:ER_SIZE    12FC
BMP_LOAD:PXL_LOOP   12E4
BMP_LOAD_REGS       C04
BMP_MAX_FILESIZE    401000
BMP_OFFS_BPP        1C
BMP_OFFS_IMGWH      12
BMP_OFFS_PIXELGET   A
BMP_OFFS_SIZE       22
BMP_SCREENHEIGHT    1E0
BMP_SCREENWIDTH     280
BMP_UNLOAD          131A
BMP_UNLOAD:DONE     132E
BMP_UNLOAD:ER_MEM   1334
D2D3_REGS           C
DELAYFRAME          1778
DELAY_FRAME         17
DOUBLE_BUFFERED_MODE  11
DRAWBEHIND          1742
DRAWBEHIND:DONE     1764
DRAWBEHIND:ERROR    176E
DRAWBMP             1C
DRAWING_MODE_TRAP_CODE  5C
DRAWRECT            1C
DRAW_RECT           171A
D_CHECKBIT          10
ENDOFMEM            3017CE
ERRORLABEL          1788
FILE_READ           1224
FILE_READ:DONE      124C
FILE_READ_REGS      404
FILE_TASK_FCLOSE    38
FILE_TASK_FCREATE   34
FILE_TASK_FOPEN     33
FILE_TASK_FREAD     35
FILE_TASK_FWRITE    36
FILE_WRITE          1254
FILE_WRITE:DONE     127C
FRAME_DELAY_TIME    2
GAMERUNNING         17CC
HANDLE_INPUT        1698
HANDLE_INPUT:CHECKA  16CE
HANDLE_INPUT:CHECKD  16DC
HANDLE_INPUT:CHECKS  16C2
HANDLE_INPUT:COLLISION  16E8
HANDLE_INPUT:DONE   170E
HANDLE_INPUT:DRAW   1704
HANDLE_INPUT:ERROR  1714
HEAP_BYTES          300000
MAKE_HEADER         11E4
MAKE_HEADER:DONE    1210
MAKE_HEADER:ERROR   120C
MAKE_HEADER:SETSIZE  11FE
MEM_ALLOC           1096
MEM_ALLOC:DONE      1112
MEM_ALLOC:ERROR     110E
MEM_ALLOC:FILL_ALLOC  10FC
MEM_ALLOC:FREE_FOUND  10C0
MEM_ALLOC:INC       10BC
MEM_ALLOC:NO_SPLIT  10FA
MEM_ALLOC:SEARCH    10A0
MEM_AUDIT           1020
MEM_AUDIT:ALLOCD    1070
MEM_AUDIT:DONE      108A
MEM_AUDIT:ERROR     1090
MEM_AUDIT:FREE      107C
MEM_AUDIT:INC       1086
MEM_AUDIT:SEARCH    1050
MEM_AUDIT_OFFS_FREE_CNT  0
MEM_AUDIT_OFFS_FREE_MEM  8
MEM_AUDIT_OFFS_USED_CNT  4
MEM_AUDIT_OFFS_USED_MEM  C
MEM_AUDIT_OVERHEAD_SIZE  10
MEM_AUDIT_RETURN_SIZE  14
MEM_COALESCE        1186
MEM_COALESCE:DONE   11DE
MEM_COALESCE:ERROR  11D8
MEM_COALESCE:FREE_FOUND  11B0
MEM_COALESCE:INC    11AC
MEM_COALESCE:SEARCH  1190
MEM_END_HEAP        1220
MEM_FREE            1118
MEM_FREE:DONE       113A
MEM_FREE:ERROR      1138
MEM_GETSIZE         1212
MEM_HEADER_SIZE     8
MEM_INITHEAP        1000
MEM_OFFSET_GETSIZE  FFFFFFF8
MEM_OFFSET_NEXT     4
MEM_OFFSET_SIZE     0
MEM_SHRINK          113C
MEM_SHRINK:DONE     117C
MEM_SHRINK:ERROR    1180
MEM_START_HEAP      121C
MHEADER_REGS        106
MOVE                A
NONVOL_REGS         7CFC
OBJARRAY            17C8
OBJ_COLLIDE         1574
OBJ_COLLIDE:COLLIDE  15B0
OBJ_COLLIDE:NO_COLLIDE  15BA
OBJ_COLLIDE_REGS    1C
OBJ_DRAW            1548
OBJ_DRAW:DONE       1560
OBJ_DRAW:ERROR      156A
OBJ_DRAW_REGS       1C
OBJ_GETCOORDS       1542
OBJ_HEADER_SIZE     18
OBJ_INIT            14D8
OBJ_INIT:DONE       1518
OBJ_INIT:ERROR      151E
OBJ_INIT_REGS       207
OBJ_OFFS_BMPADD     C
OBJ_OFFS_BMPCOORDS  4
OBJ_OFFS_BMPSIZE    8
OBJ_OFFS_CENTER     10
OBJ_OFFS_CORNER     14
OBJ_OFFS_SCREENCOORDS  0
OBJ_SETCOORDS       1528
REPAINT_SCREEN_TRAP_CODE  5E
SENTINEL            DEADDEAD
START               15C4
START:DONE          1694
START:ERROR         168A
START:GAMELOOP      166C
STARTOFMEM          17CE
SWAPBUFFERS         1780
S_CHECKBIT          8
TASK_PRINT          D
UFO                 17BA
WASD_CODES          41445357
WHITECOLOR          FFFFFF
W_CHECKBIT          0
